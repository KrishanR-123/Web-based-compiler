# Chapter 1: Introduction to Compiler 

**The compiler** converts high-level language to low-level language.<br>

## Working of Compiler
**Scanner:** Scans each and every work of the code individually. Converting input text into a stream of known objects called tokens. Simplifies the parsing process.<br>
**Parser:** Check if the word (token) formed is at the right place or not. Translating code to rules of grammar. Building representation of code.<br>
**Syntax Analyzer:** Checks if the syntax of the words formed by the parser is right or wrong.<br>
**Semantic Analyzer:** It checks if the semantics or the type of the output generated by the syntax analyzer is right or wrong and is meaningful.<br>

<br>**Intermediate Level:** Converts the output into a language closer to the assembly language.


<!--<<<<<<<<<<<<<<image>>>>>>>>>>>>>>>>-->

***Once the source code is obtained then the parser takes the token(eg; constants, variable, keyword) from the source code and checks if that token is an authenticated token or not, if not it will continue the process until it finds a partial sentence, then it will move that code to the semantic analysis where Semantic Error (eg; undeclared variable, a variable not declared in scope, incompatible type) will be checked. If all the cases are passed then the code moves to intermediate code generation.***


## Front-end:  
**Lexical Analysis:** Scanning and grouping characters into words. Lexical rules of language dictate how a legal word is formed by concatenating the alphabet.<br>
**Syntax Analysis:** Parsing and finding out if the syntax of the code is correct.<br>
**Semantic Analysis:** Check if the statement is semantically meaningful.<br><br>

## Back-end:
**Code Generation:** Conversion of code to machine/assembly level language.<br>
**Optimization:** Make sure the code is efficient. <br><br>

## Scanning & Tokenization:
For eg; main is a legal token, then pass it to the parser and then move to check the next token.

## Parser:
  - Start matching with a rule
  - When match takes place move further(get next token and repeat)
  - If expansion needs to be done choose appropriate rules.
  - If no rule found declare error
  - If many rules found grammar is ambiguous, something is wrong with it.

## Ambiguity
Ambiguity can lead to understanding a given sentence in two different ways which allow assigning two meanings to the same sentence, something highly undesirable, e.g. 1 * 2 + 3 can be interpreted as understanding 1 to be multiplied by 2 and the result to be added to 3... 2 and 3 to be added together first and then multiply 1 to the result. 

## Symbol
  - Declares variable, Within the current scope, Type integer
  - Checks for compatibility and type when variable comes later in scope

## Semantic Actions
  - Enter variable declaration into a symbol table
  - Look up variables in the symbol table 
  - Do the binding of looked-up variables (scoping rules, etc.)
  - Do type checking for compatibility
  - Keep the semantic context of processing
  - Action symbols embedded in the grammar. Each action symbol represents a semantic procedure. These procedures do things and/or return values.
  - Semantic procedures are called by the parser at appropriate places during parsing
  - Semantic stack implements & stores semantic records
  - Checking: binding, type compatibility, scoping, etc
  - Translation: generate temporary values, propagate them to keep the semantic context

